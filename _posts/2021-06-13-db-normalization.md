---
title: '[Database] 데이터베이스 정규화의 기초'
date: 2021-06-13 00:00:00 -0400
categories: database
tags: [database, normalization]
---


이 글에서는 데이터베이스 정규화에 대해서 알아봅니다. 

데이터베이스 정규화의 의미, (정규화를 하지 않았을시 발생할 수 있는) 이상 현상, 정규화의 목적, 정규화의 종류와 방법에 대해서 알아봅니다. 이 글은 위키백과의 데이터베이스 정규화, 제 1 정규형, 제 2 정규형, 제 3 정규형 내용을 참조하였습니다.

## 1. 데이터베이스 정규화란? 

관계형 데이터베이스의 설계에서 중복을 최소화하도록 구조화하는 프로세스를 **정규화(Normalization)**라고 합니다. 일반적으로 정규화란 크고 제대로 조직되지 않은 테이블들과 관계들을 작고 잘 조직된 테이블과 관계들로 나누는 것을 말합니다.


## 2. 정규화의 목적


### 2-1. 데이터베이스의 변경시 이상 현상 제거

정규화를 제대로 하지 않았을 시에는 다음과 같은 문제점이 발생할 수 있습니다.

### 2-1-1. 갱신 이상

같은 정보가 복수개의 행에서 표현된다면, **갱신 이상**(반복된 데이터 중에 일부만 갱신)을 유발합니다. 아래의 예시에서는 {Employee ID}가 519인 직원의 정보가 중복해서 나타나기 때문에, 갱신 이상이 나타난 예시입니다.


<div style="text-align:center"><img src="https://upload.wikimedia.org/wikipedia/commons/1/12/Update_anomaly.png" /></div>

<div align="center">
  <i>중복된 행으로 인해 갱신 이상이 발생 </i>
</div>

<br/>


### 2-1-2. 삽입 이상

삽입 이상은 불필요한 정보를 함께 저장하지 않고서는 어떤 정보를 저장하는 것이 불가능해지는 현상입니다. 아래 테이블에서 {Course Code} 정보가 없는 행을 입력하기 위해서는, `null`로 하지 않는 이상 새 테이블에 추가할 수가 없습니다. 


<div style="text-align:center"><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/5/5c/Insertion_anomaly.svg/1920px-Insertion_anomaly.svg.png" /></div>

<div align="center">
  <i>행의 일부 값이 없어서 삽입 이상 발생</i>
</div>

<br/>


### 2-1-3. 삭제 이상

삭제 이상은 다른 필요한 정보를 함께 삭제하지 않고서는 어떤 정보를 삭제하는 것이 불가능하게 되는 현상입니다. 아래 테이블에서 한 교수가 임시로 강의를 중단하고자 할때, 그가 기록된 레코드들을 삭제해야 하는데, 그럴 경우 필요한 정보들(예를 들어, {Faculty Hire Date})도 함께 사라지게 됩니다.




<div style="text-align:center"><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/2/2c/Deletion_anomaly.svg/1920px-Deletion_anomaly.svg.png" /></div>

<div align="center">
  <i>한 행을 삭제할 때 여러 정보가 함께 유실되는 삭제 이상 발생</i>
</div>

<br/>


### 2-2. 데이터베이스 구조 확장시 재 디자인 최소화

정규화된 데이터베이스 구조는 새로운 데이터 형의 추가로 인한 확장시, 그 구조를 변경하지 않아도 되거나, 변경해야 할 것을 최소화합니다.

### 2-3. 사용자에게 의미 있는 데이터 모델 전달

정규화된 테이블들과 정규화된 테이블들간의 관계들은 현실세계에서의 개념들과 그들간의 관계들을 반영하므로, 모델이 사용자에게 더욱 의미(informative)있게 합니다.

### 2-4. 다양한 질의 지원

정규화된 테이블은 일반적인 목적의 질의에 적합하도록 구성됩니다. 반대로 정규화되지 않은 테이블은 (향후 발생할 수 있는) 어떤 질의들은 지원하지 않을 수 있습니다.

<br/>

## 3. 정규화의 종류

### 3-1. 제 1 정규형 (1NF)

관계형 데이터베이스의 테이블이 1NF이면 최소한 테이블은 관계를 나타내야 하며, 중복되는 항목이 없어야 합니다. 제 1 정규형은 다음 표준을 요구합니다.

> **제 1 정규형의 조건**
> 
>- 각 테이블에서 중복을 제거한다.
>- 각각 관계된 데이터 모임을 위하여 분리된 테이블을 만든다.
>- 각각 관계된 데이터 모임을 기본키로 식별한다.

다음과 같은 Customer 테이블이 있다고 합시다.

<div style="text-align:center"><img src="https://user-images.githubusercontent.com/71360682/121801107-90a3f600-cc70-11eb-9083-d809f0cbc049.png" /></div>

<div align="center">
  <i>제 1 정규형을 만족하지 않는 테이블 예시</i>
</div>

<br/>


이 때 고객마다 전화번호가 1개 이상이라면, 다음과 같이 2개의 테이블을 이용하면 됩니다.


<div style="text-align:center"><img src="https://user-images.githubusercontent.com/71360682/121801121-a3b6c600-cc70-11eb-8430-29b4f6043144.png" /></div>

<div align="center">
  <i>제 1 정규형을 만족하도록 분리 후</i>
</div>

<br/>


### 3-2. 제 2 정규형 (2NF)

제 1 정규형(1NF)인 테이블이 제 2 정규형을 충족시키는 필요충분조건은 다음과 같습니다. 

> **제 2 정규형의 조건**
> 
> 후보 키 K와 K에 속하지 않는 속성 A가 있을 때, A를 결정하기 위해 K의 일부가 아닌 K 전체를 참조해야만 하는 경우 1NF 테이블은 2NF이다.

다음은 제 2 정규형을 만족하지 않는 테이블의 예시입니다.

<div style="text-align:center"><img src="https://user-images.githubusercontent.com/71360682/121801294-9948fc00-cc71-11eb-874a-ecb3980846b2.png" /></div>

<div align="center">
  <i>제 2 정규형을 만족하지 않는 테이블 예시</i>
</div>

<br/>


{종업원} 이나 {기술}은 둘다 이 테이블의 후보키는 아닙니다. 오직 복합 키 {종업원, 기술} 이 이 테이블의 후보 키입니다. 그런데 {근무지}는 후보 키의 일부분인 {종업원}에만 영향을 받기 때문에 이 테이블은 2NF가 아닙니다. 이 경우 발생할 수 있는 문제점은 다음과 같습니다.

1. **(갱신 이상)** {종업원}과 {근무지}가 중복되므로 갱신 이상의 원인이 됩니다. 

2. **(삭제 이상)** 특정 기술에 대한 정보를 삭제하면 종업원의 근무지 정보를 소실합니다.

3. **(삽입 이상)** 종업원의 근무지를 모르는 경우 등록할 수 없습니다.

이 디자인을 2NF로 표현하는 방법은 같은 데이터를 2개의 테이블로 표현하는 것입니다. {종업원} 후보 키를 갖는 "종업원" 테이블과 {종업원,기술} 후보 키를 갖는 "종업원의 기술" 테이블입니다.


<div style="text-align:center"><img src="https://user-images.githubusercontent.com/71360682/121801340-cf867b80-cc71-11eb-90f1-94e9013041ce.png" /></div>

<div align="center">
  <i>제 2 정규형을 만족하도록 분리 후</i>
</div>

<br/>

### 3-3. 제 3 정규형 (3NF)

제 3 정규형이란 데이터베이스 정규화의 세 번째 단계로, 다음 조건을 만족해야 합니다.

> **제 3 정규형의 조건**
> 
>  테이블이 제 2 정규형을 만족하고, 테이블 내의 모든 속성이 기본 키에만 의존하며, 추이 종속이 존재하지 않는다.

제 3 정규형의 조건을 만족하지 않는 2NF의 예시는 다음과 같습니다.

<div style="text-align:center"><img src="https://user-images.githubusercontent.com/71360682/121801439-3441d600-cc72-11eb-81b8-4e483489c1cf.png" /></div>

<div align="center">
  <i>제 3 정규형을 만족하지 않는 테이블 예시</i>
</div>

<br/>

여기서 후보키는 {대회, 연도} 인데, {우승자 생년 월일}은 다른 키 {우승자}에 의존하기 때문에 제 3 정규형이 아닙니다. 이 경우 발생할 수 있는 문제점은 다음과 같습니다.

1. **(갱신 이상)** {우승자}, {우승자 생년월일}이 중복으로 나타나므로 갱신 이상이 발생할 수 있습니다.

2. **(삭제 이상)** 특정 대회에 대해 삭제하면 우승자에 대한 생년 월일 정보를 소실합니다.

3. **(삽입 이상)** 우승자의 생년 월일이 없는 경우 등록할 수 없습니다.

4. 우승자의 생년월일이 다른 테이블에서 다르게 저장되어 있을 모순이 발생할 경우 이를 막을 방법이 없습니다.

이 테이블을 3NF로 변형하면 다음과 같습니다.

<div style="text-align:center"><img src="https://user-images.githubusercontent.com/71360682/121801451-40c62e80-cc72-11eb-8a0e-1f2777917e00.png" /></div>

<div align="center">
  <i>제 3 정규형을 만족하도록 분리 후</i>
</div>

<br/>



## 4. 결론

이 글에서는 크고 제대로 조직되지 않은 테이블들과 테이블 간의 관계를 작고 잘 조직된 것으로 분할하는 데이터베이스 정규화 작업에 대해서 알아보았습니다.

정규화는 데이터의 이상 발생 가능성을 줄이지만, 더 많은 읽기, Join 연산이 요구될 수 있다는 단점이 있습니다. 따라서 데이터베이스를 정규화한 후에 **역정규화(Denormalization)**를 통해서 쓰기 속도, 저장 공간, 무결성 등을 희생시키는 대신 읽기 속도를 빠르게 할 수 있습니다.

다만 이러한 역정규화는 반드시 정규화 이후에 진행되어야 하며, 데이터베이스에 대한 이해를 바탕으로 신중히 진행되어야 합니다.



## 참고자료


[[1] (위키백과) 데이터베이스 정규화](https://www.notion.so/Database-cd124f0ecd184e78af8acae3fb6822af)

[[2] (위키백과) 제1정규형](https://ko.wikipedia.org/wiki/%EC%A0%9C1%EC%A0%95%EA%B7%9C%ED%98%95)

[[3] (위키백과) 제2정규형](https://ko.wikipedia.org/wiki/%EC%A0%9C2%EC%A0%95%EA%B7%9C%ED%98%95)

[[4] (위키백과) 제3정규형](https://ko.wikipedia.org/wiki/%EC%A0%9C3%EC%A0%95%EA%B7%9C%ED%98%95)